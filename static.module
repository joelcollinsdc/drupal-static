<?php

/**
 * @file
 * Static site generator for Drupal.
 */

/**
 * Value for expired content.
 */
define('STATIC_EXPIRED', 0);

/**
 * Value for current content
 */
define('STATIC_CURRENT', 1);

/**
 * Value for error content
 */
define('STATIC_ERROR', 2);

/**
 * Default value for the root cache dir.
 */
define('STATIC_ROOT_CACHE_DIR', 'static');

/**
 * Default value for the normal cache dir.
 */
define('STATIC_NORMAL_DIR', 'normal');

/**
 * Define the default cron limit
 */
define('STATIC_DEFAULT_CRON_LIMIT', 60);

/**
 * Use this function to tell the static module to track paths. This is useful
 * for submodules to make sure that all paths get included.
 */
function static_track_paths($paths) {
  // There probably is some way to optimize this.
  foreach($paths as $path) {
    static_track_path($path);
  }
}

/**
 * Track a single path.
 * 
 * @param type $path can either be a string which represents the path or an
 * info array.
 * 
 * For multiple paths, use static_track_paths
 */
function static_track_path($path) {
  if (is_array($path)) {
    $info = static_get_info($path['path']);
    $info = $path + $info; // Merge the arrays.
  }
  else {
    $info = static_get_info($path);
  }
  // Only process new paths
  if (!isset($info['id'])) {
    static_save_info($info);
  }
}

/**
 * Implements hook_menu().
 */
function static_menu() {
  $items = array();

  $items['admin/config/system/static'] = array(
    'title' => 'Static Generator',
    'description' => 'Configuration for the static generator.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('static_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'static.admin.inc',
  );

  $items['admin/config/system/static/regenerate'] = array(
    'title' => 'Regenerate',
    'description' => 'Queue all items for regeneration.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('static_admin_confirm', 4),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'static.admin.inc',
  );

  $items['admin/config/system/static/clear'] = array(
    'title' => 'Clear static cache',
    'description' => 'Clear all the static files for the generator.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('static_admin_confirm', 4),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'static.admin.inc',
  );

  return $items;
}

/**
 * Load a static path info
 */
function static_get_info($path) {
  // Special case for the front page since it is weird.
  if ($path == '' || $path == '<front>') {
    $path_alias = array(
      'source' => '<front>',
      'alias' => '',
    );
  }
  else {
    // Ensure this is the normal path.
    $path = drupal_get_normal_path($path);

    $path_alias = path_load(array('source' => drupal_get_normal_path($path)));

    if (!$path_alias) {
      $path_alias = array(
        'source' => $path,
        'alias' => $path,
      );
    }
  }

  $info = db_select('static', 's')
    ->fields('s')
    ->condition('path', $path_alias['source'])
    ->execute()
    ->fetchAssoc();
  
  // In case this is new.
  if (!$info) {
    $info = array(
      'path' => $path_alias['source'],
      'alias' => $path_alias['alias'],
      'status' => STATIC_EXPIRED,
    );
  }
  
  // Alias may have changed. Record it here.
  $info['alias'] = $path_alias['alias'];
  
  // Allow other modules to alter.
  drupal_alter('static_info', $info);
  
  return $info;
}

/**
 * Save a static path
 */
function static_save_info($info) {
  $keys = array();
  if (isset($info['id'])) {
    $keys[] = 'id';
  }
  drupal_write_record('static', $info, $keys);
}

/**
 * Generate a filename
 */
function static_filename($info) {
  // Special case for index.html
  if ($info['alias'] == '') {
    $filename = 'index.html';
  }
  else {
    $filename =  $info['alias'];
    
    // If the filename does not have .html, add it.
    if (substr_compare($filename, '.html', -5, 5) !== 0) {
      $filename .= '.html';
    }
  }
  
  // Allow other modules to modify the filename.
  drupal_alter('static_filename', $filename, $info);
  
  return $filename;
}

/**
 * Function to set a path to regenerate
 */
function static_set_expired($path) {
  $paths = &drupal_static(__FUNCTION__);
  
  $info = static_get_info($path);
  if (!isset($paths[$info['path']])) {
    $info['status'] = STATIC_EXPIRED;

    static_save_info($info);
    
    $paths[$info['path']] = TRUE;
  }
}

/**
 * Implements hook_expire_cache (from the 'expire' module)
 */
function static_expire_cache($paths) {
  global $base_root;

  if (variable_get('static_cron', TRUE)) {
    foreach ($paths as $path => $absolute) {
      static_set_expired($path);
    }
  }
}

/**
 * Implements hook_cron()
 */
function static_cron() {
  if (variable_get('static_cron', TRUE)) {
    $cache_time = variable_get('static_dynamic_cache_time', 300);
    if ($cache_time >= 0) { // In case set to "never"
      db_update('static')
        ->fields(array(
          'status' => 0
        ))
        ->condition('dynamic', 1)
        ->condition('updated', REQUEST_TIME - $cache_time, '<=')
        ->execute();
    }
    
    $results = db_select('static', 's')
      ->fields('s', array('path'))
      ->condition('status', 0)
      ->execute()
      ->fetchAllKeyed(0,0);
    foreach($results as $path) {
      // Put URLs in a queue for processing by cron
      $queue = DrupalQueue::get('static');
      $queue->createItem($path);
    }
  }
}

/**
 * Implements hook_cron_queue_info()
 */
function static_cron_queue_info() {
  $queues['static'] = array(
    'worker callback' => 'static_generate_file',
    'time' => variable_get('static_queue_seconds', 30), // max run time to claim per cron run (in seconds).
  );

  return $queues;
}

/**
 * Worker Callback for batches.
 */
function static_generate_file($path) {
  global $base_url;
  $info = static_get_info($path);
  // If status is 1, we don't want to regenerate again. Only regenerated status 0
  // This can happen when items get left in the queue and are there for multiple runs.
  if ($info['status']) {
    return TRUE;
  }
  $absolute_url = url($info['alias'], array('absolute' => TRUE, 'alias' => TRUE));
  
  httprl_request($absolute_url);
  $request = httprl_send_request();
  
  if ($request[$absolute_url]->code == 200) {
    static_set_filename($info);
    $info['status'] = STATIC_CURRENT;
    $info['updated'] = REQUEST_TIME;
    
    static_save_info($info);
    
    // Drupal creates absolute urls for many links. We need to make these relative.
    $data = str_replace($base_url, '', $request[$absolute_url]->data);
    
    static_copy_linked_files($data);
    
    // Set to 755 so ssi can include.
    static_write_file(static_get_normal_cache_dir() . '/' . $info['file'], $data, 0755);
  }
  
  else {
    // This can happen if something is deleted. We want to remove the corresponding file.
    if ($request[$absolute_url]->code == 404 && $info['file']) {
      @unlink(static_get_normal_cache_dir() . '/' . $info['file']);
    }
    $info['status'] = STATIC_ERROR;
    static_save_info($info);
  }

  watchdog('static', 'Statically generated !file', array('!file' => $info['file']), WATCHDOG_DEBUG);
}

/**
 * Find any linked files within the page and copy them over to the destination.
 * 
 * @param type $data
 */
function static_copy_linked_files($data) {
  // Should find a way of caching the results so we aren't constantly 
  // checking common files.
  $wrapper = file_stream_wrapper_get_instance_by_uri('public://');
  $files_dir = $wrapper->getDirectoryPath();
  $srcs = array();
  // Match src="/{anything}"
  preg_match_all('/src="\/([^"]*)"/i', $data, $srcs);
  $hrefs = array();
  // Match href="/{anything}.{ico|css|pdf|doc}(?{anything})" () querystring is optional
  preg_match_all('/href="\/([^"]*.\.(' . variable_get('static_href_link_types', 'ico|css|pdf|doc') . ')(\?[^"]*.)?)"/i', $data, $hrefs);
  $matches = array_merge($srcs[1], $hrefs[1]);
  foreach($matches as $match) {
    // Strip off the querystring.
    $cleanfile = preg_replace('/\?.*/', '', $match);
    // Don't copy if the file already exists.
    if (!file_exists(static_get_normal_cache_dir() . '/' . $cleanfile)) {
      // Make sure the destination exists.
      $directory = dirname(static_get_normal_cache_dir() . '/' . $cleanfile);
      if (!static_mkdir($directory)) {
        return FALSE;
      }
      // Special case for image styles. We can't directly copy if they haven't
      // been generated yet.
      if (strpos($match, $files_dir . '/styles') === 0 && !file_exists(static_get_normal_cache_dir() . '/' . $cleanfile)) {
        // Should optimize this for multithreaded gets.
        $absolute_url = urldecode(url($match, array('absolute' => TRUE, 'alias' => TRUE)));
        httprl_request($absolute_url);
        $request = httprl_send_request();

        if ($request[$absolute_url]->code == 200) {
          static_write_file(static_get_normal_cache_dir() . '/' . $cleanfile, $request[$absolute_url]->data, 0644);
        }
      }
      else {
        copy($cleanfile, static_get_normal_cache_dir() . '/' . $cleanfile);
      }
    }
  }
}

/**
 * Callback to generate multiple files based on files with status=0
 */
function static_generate_files($limit) {
  // May be a way to do multiple requests at a time to optimize this.
  $results = db_select('static', 's')
      ->fields('s')
      ->condition('status', STATIC_EXPIRED)
      ->range(0, $limit)
      ->execute()
      ->fetchAllAssoc('id');
  
  foreach($results as $id => $result) {
    static_generate_file($result->path);
  }
}

/**
 * Set the filename if needed. If it already exists but is different, delete the
 * old file and create a redirect.
 */
function static_set_filename(&$info) {
  $newfile = static_filename($info);
  // Check to see if a file previously existed but is different.
  if ($info['file'] != '' && $info['file'] != $newfile) {
    // This is a simple html page that redirects to the new page.
    $data = '<html>' . PHP_EOL
        . '  <head>' . PHP_EOL
        . '    <meta http-equiv="refresh" content="0;URL=/' . $newfile . '">' . PHP_EOL
        . '  </head>' . PHP_EOL
        . '  <body>' . PHP_EOL
        . '    <a href="/' . $newfile . '">Page has moved to this location.</a>' . PHP_EOL
        . '  </body>' . PHP_EOL
        . '</html>' . PHP_EOL;
    
    // Create directory if it doesn't exist.
    $directory = dirname(static_get_normal_cache_dir() . '/' . $info['file']);
    if (!static_mkdir($directory)) {
      return FALSE;
    }
    // Save the redirect to the system.
    if (file_put_contents(static_get_normal_cache_dir() . '/' . $info['file'], $data) === FALSE) {
      watchdog('static', 'Could not create the file %file on your system', array('%file' => $filename), WATCHDOG_ERROR);
      return FALSE;
    }
    
  }
  
  $info['file'] = $newfile;
}

/**
 * Write to a file. Ensures write is atomic via rename operation.
 *
 * @param $filename
 *  relative filename.
 * @param $data
 *  data to write to the file.
 */
function static_write_file($filename, $data, $chmod = 0644) {
  // Create directory if it doesn't exist.
  $directory = dirname($filename);
  if (!static_mkdir($directory)) {
    return FALSE;
  }

  // Save the file to the system.
  if (file_put_contents($filename, $data) === FALSE) {
    watchdog('static', 'Could not create the file %file on your system', array('%file' => $filename), WATCHDOG_ERROR);
    return FALSE;
  }

  // chmod file so webserver can send it out.
  drupal_chmod($filename, $chmod);
  return TRUE;
}

/**
 * Create a directory.
 *
 * @param $directory
 *  relative directory.
 */
function static_mkdir($directory) {
  global $_static;

  // Only do something if it's not a dir.
  if (!is_dir($directory)) {
    if (!static_in_cache_dir($directory)) {
      return FALSE;
    }

    // Try to create the directory.
    $mode = variable_get('file_chmod_directory', 0775);
    if (!mkdir($directory, $mode, TRUE)) {
      watchdog('static', 'Could not create the directory %dir on your system', array('%dir' => $directory), WATCHDOG_ERROR);
      return FALSE;
    }
    drupal_chmod($directory);
  }
  return TRUE;
}

/**
 * Returns the relative normal static dir. static/normal.
 */
function static_get_normal_cache_dir() {
  return variable_get('static_root_cache_dir', STATIC_ROOT_CACHE_DIR) . '/' . variable_get('static_normal_dir', STATIC_NORMAL_DIR);
}

/**
 * Verify that the operation is going to operate in the cache dir.
 *
 * @param $file
 *  relative directory or file.
 */
function static_in_cache_dir($file) {
  global $_static;

  $good = TRUE;
  $real_file = realpath($file);
  $cache_dir = variable_get('static_root_cache_dir', STATIC_ROOT_CACHE_DIR);
  $real_cache_dir = realpath($cache_dir);

  // Only operate in the cache dir.
  // Check the real path.
  if (   strpos($file, $cache_dir) !== 0
      || ($real_file && $real_cache_dir && strpos($real_file, $real_cache_dir) !== 0)
        ) {
    $good = FALSE;
  }

  // Send error to watchdog.
  if (!$good) {
    watchdog('static', 'An operation outside of the cache directory was attempted on your system. %file or %real_file is outside the cache directory %cache or %real_cache. Debug info below <br> !debug', array(
      '%file'       => $file,
      '%real_file'  => $real_file,
      '%cache'      => $cache_dir,
      '%real_cache' => $real_cache_dir,
      '!debug'      => print_r($_static),
      ),
    WATCHDOG_CRITICAL);
  }

  return $good;
}

/**
 * Set all pages to be regenerated
 */
function static_regenerate() {
  // Make sure we know about all paths in case some got missed.
  static_refresh_paths();
  
  db_update('static')
    ->fields(array(
      'status' => 0,
    ))
    ->execute();
  
  return TRUE;
}

/**
 * Clear out all static pages.
 */
function static_clear() {
  static_regenerate();
  
  //$static_delete_dir = drupal_realpath(static_get_normal_cache_dir());
  static_delete_dir(drupal_realpath(static_get_normal_cache_dir()));
  
  // Call the requirements to make sure all the links gets linked again.
  include_once drupal_get_path('module', 'static') . '/static.install';
  static_requirements('runtime');

  return TRUE;
}

/**
 * function to delete directory and everything under it.
 */
function static_delete_dir($dir) {
  $files = array_diff(scandir($dir), array('.','..')); 
  foreach ($files as $file) { 
    if (is_link("$dir/$file") || is_file("$dir/$file")) {
      drupal_unlink("$dir/$file");
    }
    elseif (is_dir("$dir/$file")) {
      static_delete_dir("$dir/$file");
    }
  } 
  return drupal_rmdir($dir); 
}

/**
 * Creates and sets a batch for generating items.
 *
 * @param int $batch_size
 *   Number of items to generate per batch.
 *
 * @return bool
 *   Whether the batch was created and set successfully.
 */
function _static_batch_generating_create($batch_size) {
  $limit = -1;
  $remaining = $batch_size;
  if ($limit !== 0 && $batch_size !== 0) {
    if ($limit < 0 || $limit > $remaining) {
      $limit = $remaining;
    }
    if ($batch_size < 0) {
      $batch_size = $remaining;
    }
    $batch = array(
      'title' => t('Generating pages'),
      'operations' => array(
        array('_static_batch_generating_callback', array($batch_size)),
      ),
      'progress_message' => t('Completed about @percentage% of the generating operation.'),
      'finished' => '_static_batch_generating_finished',
      'file' => drupal_get_path('module', 'static') . '/static.module',
    );
    batch_set($batch);
    return TRUE;
  }
  return FALSE;
}

/**
 * Batch API callback for the generating functionality.
 *
 * @param integer $batch_size
 *   Number of items to generate per batch.
 * @param $context
 *   An array (or object implementing ArrayAccess) containing the batch context.
 */
function _static_batch_generating_callback($batch_size, &$context) {
  // Persistent data among batch runs.
  if (!isset($context['sandbox']['batch_size'])) {
    $query = db_select('static', 's');
    $query->fields('s');
    $query->condition('status', STATIC_EXPIRED);
    $result = $query->execute();
    $context['sandbox']['limit'] = $result->rowCount();

    $context['sandbox']['batch_size'] = $batch_size;
    $context['sandbox']['progress'] = 0;
  }

  // Persistent data for results.
  if (!isset($context['results']['generated'])) {
    $context['results']['generated'] = 0;
    $context['results']['not generated'] = 0;
  }

  // Number of items to generate for this run.
  $to_generate = min($context['sandbox']['limit'] - $context['sandbox']['progress'], $context['sandbox']['batch_size']);

  // Index the items.
  try {
    $generated = static_generate_files($to_generate);
    $context['results']['generated'] += $generated;
  }
  catch (Exception $e) {
    watchdog_exception('static', $e);
    $vars['@message'] = $e->message;
    $context['message'] = t('An error occurred during generating: @message.', $vars);
    $context['finished'] = 1;
    $context['results']['not generated'] += $context['sandbox']['limit'] - $context['sandbox']['progress'];
    return;
  }

  // Display progress message.
  if ($generated > 0) {
    $context['message'] = format_plural($context['results']['generated'], 'Successfully generated 1 item.', 'Successfully generated @count items.');
  }

  // Some items couldn't be generated.
  if ($generated !== $to_generate) {
    $context['results']['not generated'] += $to_generate - $generated;
  }

  $context['sandbox']['progress'] += $to_generate;

  // Everything has been generated.
  if ($generated === 0 || $context['sandbox']['progress'] >= $context['sandbox']['limit']) {
    $context['finished'] = 1;
  }
  else {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['limit'];
  }
}

/**
 * Refresh all known paths for the static module
 */
function static_refresh_paths() {
  // On larger sites this might run into php limit issues (memory and time).
  $paths = module_invoke_all('static_refresh_paths');
  
  drupal_alter('static_refresh_paths', $paths);
  
  static_track_paths($paths);
}

/**
 * Implements hook_static_refresh_paths()
 * 
 * Return info about system paths.
 */
function static_static_refresh_paths() {
  $paths = array();
  $paths[''] = array(
    'path' => '<front>',
    'dynamic' => 1,
  );
  $paths['node'] = array(
    'path' => 'node',
    'pager' => 'page',
    'dynamic' => 1,
  );
  $site_404 = variable_get('site_404', '');
  if ($site_404 != '') {
    $paths[$site_404] = array(
      'type' => 'system',
      'path' => $site_404,
    );
  }
  $site_403 = variable_get('site_403', '');
  if ($site_403 != '') {
    $paths[$site_403] = array(
      'type' => 'system',
      'path' => $site_403,
    );
  }
  return $paths;
}
